# --- AoC 2025 - Day X: Your Puzzle Title ---
# (Replace 'Day X' and 'Your Puzzle Title' with the actual day and title)

# 0. Configuration and Imports
# -----------------------------------------------------------------------------
import os
import sys
# Add any other necessary imports here, e.g.:
# import numpy as np
# import pandas as pd
# import re
# from collections import defaultdict, Counter, deque
# import math

# Define input filename - typically both parts use the same 'input.txt'
INPUT_FILENAME = "input.txt"

# Set up paths for convenience
NOTEBOOK_DIR = os.path.dirname(os.path.abspath('__file__')) # Gets directory of this notebook


# 1. Load Input Data
# -----------------------------------------------------------------------------
def load_input_data(filename):
    """
    Loads input data from a specified file.
    Assumes the input file is in the same directory as the notebook.
    """
    filepath = os.path.join(NOTEBOOK_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            # Read all lines and strip whitespace from each
            return [line.strip() for line in f.readlines()]
            # If your input is a single block of text, use:
            # return f.read().strip()
    except FileNotFoundError:
        print(f"Error: Input file '{filename}' not found at '{filepath}'")
        return [] # Return an empty list to prevent further errors

# Load the raw data once for both parts
raw_data = load_input_data(INPUT_FILENAME)

# Optional: Print a preview of the data to ensure it loaded correctly
print(f"Loaded {len(raw_data)} lines from '{INPUT_FILENAME}'.")
# print(f"First 5 lines: {raw_data[:5]}\n")


# =============================================================================
# >>> START PART 1 (Solve this first!) <<<
# =============================================================================

# 2. Part 1 Data Preprocessing / Parsing
# -----------------------------------------------------------------------------
# This function will process the raw_data specifically for Part 1's requirements.
# It might involve converting strings to integers, splitting lines, etc.
def parse_data_part1(data_lines):
    """
    Parses the raw input data for Part 1 into a more usable format.
    Customize this based on the specific puzzle.
    """
    print("Parsing data for Part 1...")
    if not data_lines: # Handle empty data case
        return []

    # --- Your Part 1 Parsing Logic Here ---
    # Example: If each line is an integer
    # return [int(line) for line in data_lines if line]

    # Example: If lines are comma-separated values
    # return [line.split(',') for line in data_lines if line]

    return data_lines # Placeholder: returning raw data if no specific parsing is needed yet

parsed_input_part1 = parse_data_part1(raw_data)


# 3. Part 1 Solution Algorithm
# -----------------------------------------------------------------------------
def solve_part1(data):
    """
    Solves the first part of the puzzle.
    'data' here is the preprocessed input specifically for Part 1.
    """
    print("Solving Part 1...")
    # --- Your Part 1 Algorithm Here ---
    # This is where the core logic to find the Part 1 answer goes.
    # It should operate on the 'data' structure created by parse_data_part1.

    # Placeholder result
    return "Part 1 Solution Not Implemented Yet"

part1_answer = solve_part1(parsed_input_part1)
print(f"Part 1 Answer: {part1_answer}\n")


# 4. Part 1 Testing (Optional but Recommended)
# -----------------------------------------------------------------------------
# If the problem provides example inputs and expected outputs for Part 1,
# use this section to verify your solve_part1 function.

# EXAMPLE_INPUT_PART1_STR = """
# 1721
# 979
# 366
# 299
# 675
# 1456
# """ # Example for AoC Day 1, Year 2020
# EXAMPLE_EXPECTED_PART1 = 514573 # Expected product of two numbers that sum to 2020

# def test_part1():
#     print("Running Part 1 example test...")
#     # Ensure your parse_data_part1 can handle the example format
#     example_raw_data = EXAMPLE_INPUT_PART1_STR.strip().split('\n')
#     example_parsed_data = parse_data_part1(example_raw_data)
#     result = solve_part1(example_parsed_data)
#     assert result == EXAMPLE_EXPECTED_PART1, \
#         f"Part 1 Example Failed! Expected {EXAMPLE_EXPECTED_PART1}, Got {result}"
#     print("Part 1 example test passed!\n")

# # Uncomment the line below to run your Part 1 test after implementing solve_part1
# # test_part1()
# =============================================================================
# >>> START PART 2 (Only after solving Part 1) <<<
# =============================================================================

# 5. Part 2 Data Preprocessing / Parsing (often reuses Part 1's parsing, or slightly modifies it)
# -----------------------------------------------------------------------------
# Sometimes Part 2 uses the exact same parsed data as Part 1.
# Other times, it requires a slight modification or even a completely different parsing.
def parse_data_part2(data_lines):
    """
    Parses the raw input data for Part 2.
    Often, this is identical to parse_data_part1, or a minor variation.
    """
    print("Parsing data for Part 2...")
    if not data_lines:
        return []

    # --- Your Part 2 Parsing Logic Here ---
    # You might reuse parse_data_part1 directly if the structure is the same:
    # return parse_data_part1(data_lines)

    # Or modify slightly:
    # return [int(line) * 2 for line in data_lines if line] # Example: double each number

    return data_lines # Placeholder: returning raw data

parsed_input_part2 = parse_data_part2(raw_data)


# 6. Part 2 Solution Algorithm
# -----------------------------------------------------------------------------
def solve_part2(data):
    """
    Solves the second part of the puzzle.
    'data' here is the preprocessed input specifically for Part 2.
    """
    print("Solving Part 2...")
    # --- Your Part 2 Algorithm Here ---
    # This is where the core logic to find the Part 2 answer goes.
    # It should operate on the 'data' structure created by parse_data_part2.

    # Placeholder result
    return "Part 2 Solution Not Implemented Yet"

part2_answer = solve_part2(parsed_input_part2)
print(f"Part 2 Answer: {part2_answer}\n")


# 7. Part 2 Testing (Optional but Recommended)
# -----------------------------------------------------------------------------
# If the problem provides example inputs and expected outputs for Part 2,
# use this section to verify your solve_part2 function.

# EXAMPLE_INPUT_PART2_STR = EXAMPLE_INPUT_PART1_STR # Often the same example input as Part 1
# EXAMPLE_EXPECTED_PART2 = 241861950 # Example for AoC Day 1, Year 2020, three numbers sum to 2020

# def test_part2():
#     print("Running Part 2 example test...")
#     example_raw_data = EXAMPLE_INPUT_PART2_STR.strip().split('\n')
#     example_parsed_data = parse_data_part2(example_raw_data) # Use parse_data_part2
#     result = solve_part2(example_parsed_data)
#     assert result == EXAMPLE_EXPECTED_PART2, \
#         f"Part 2 Example Failed! Expected {EXAMPLE_EXPECTED_PART2}, Got {result}"
#     print("Part 2 example test passed!\n")

# # Uncomment the line below to run your Part 2 test after implementing solve_part2
# # test_part2()
